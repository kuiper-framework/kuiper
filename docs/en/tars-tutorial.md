# TARS Tutorial

[TARS](https://github.com/TarsCloud/Tars/blob/master/README.zh.md) is a high-performance
RPC development framework open source by Tencent, integrating features such as service discovery,
operation and maintenance management, and service monitoring.
The official PHP library provided by TARS is quite cumbersome to use,
and the code is not easy to maintain. The Kuiper framework does a lot of work in terms of ease of use,
and can be very convenient for developing TARS RPC services.

## Create the project

Similarly, we create a project using a project template:

```bash
composer create-project kuiper/skeleton:^0.2 app
```

Select the service type for item 5 of the Tars TCP RPC service:

```
Choose server type: 
[1] Http Web Server
[2] JsonRPC Web Server
[3] JsonRPC TCP Server
[4] Tars HTTP Web Server
[5] Tars TCP RPC Server
Make your selection (1): 5
```

## File directory structure

The build project directory structure is as follows:

```
|-- composer.json
|-- config.conf
|-- config.conf.example
|-- console
|-- .env
|-- resources
|   `-- serve.sh
|-- src
|   |-- application
|   |   `-- HelloServantImpl.php
|   |-- config.php
|   |-- container.php
|   |-- index.php
|   `-- servant
|       `-- HelloServant.php
`-- tars
    `-- servant
        `-- hello.tars
```

Compared to the jsonrpc service, we have a few more files. We declare the interface in `src/servant/helloServant.php` using servant as the package name.

```php
<?php

declare(strict_types=1);

/**
 * NOTE: This class is auto generated by Tars Generator (https://github.com/wenbinye/tars-generator).
 *
 * Do not edit the class manually.
 * Tars Generator version: 1.0
 */

namespace appservant;

use kuiper\tars\attribute\TarsParameter;
use kuiper\tars\attribute\TarsReturnType;
use kuiper\tars\attribute\TarsServant;

#[TarsServant("HelloObj")]
interface HelloServant
{
    #[TarsReturnType("string")]
    public function say(#[TarsParameter(type: "string")] string $message): string;
}
```

A lot of annotations are used in this file, and as noted in the file comments,
this file is generated by the [tars-generator](https://github.com/wenbinye/tars-generator) tool.
The original file is `tars/servant/hello.tars`:

```
module app
{
    interface Hello
    {
        string say(string message);
    };
};
```

Run the `composer gen` command to generate the `HelloServant.php` file.

## Service implementation

`src/application/HelloServantImpl.php` is an implementation of a service interface,
no different from a normal application service:

```php
<?php

declare(strict_types=1);

namespace appapplication;

use kuiper\di\attribute\Service;
use app\servant\HelloServant;

#[Service]
class HelloServantImpl implements HelloServant
{
    /**
     * {@inheritdoc}
     */
    public function say(string $message): string
    {
        return "hello $message";
    }
}
```

Here we use the `kuiper\di\attribute\Service` annotation to register the service implementation with the container.

TARS applications do not depend on the tars platform to run, and local services can be started using `composer serve`.
Local services, like applications deployed on the TARS platform, require a configuration file to be specified at startup,
which is the `config.conf` file. `config.conf` defaults to the same as `config.conf.example`,
but is not committed to a git repository.

## Client invocation

When the TARS application is deployed to the tars platform, the service address is registered with the tars service registry.
However, when executed locally, the registry is missing, and the service address needs to be specified
through the service configuration. Let's first demonstrate how to call tars RPC in this way.

Again, let's create another project to call the local service.

```bash
composer create-project kuiper/skeleton:^0.2 app2
```

This time we chose to use the Tars HTTP Server to demonstrate how to call the Tars RPC service:

```
Choose server type: 
[1] Http Web Server
[2] JsonRPC Web Server
[3] JsonRPC TCP Server
[4] Tars HTTP Web Server
[5] Tars TCP RPC Server
Make your selection (1): 4
```

Add the code generation configuration file `tars/config.json` to the tars directory to specify the service name:

```json
{
    "client": {
        "servants": {
            "Hello": "app.demo.HelloObj"
        }
    }
}
```

Copy the `tars/servant/hello.tars` of the above tars service to the current directory `tars/client/hello.tars` and generate the code:

```bash
mkdir tars/client
cp .. /app/tars/servant/hello.tars tars/client
composer gen
```

The generated code is in the `src/integration` directory, namespaced after the module name in the tars file.

Add the service address configuration in the configuration file `src/config.php`:

```php
<?php

declare(strict_types=1);

use app2\integration\app\HelloServant;

return [
    'application' => [
        // ... Other configurations
        'tars' => [
            'client' => [
                'options' => [
                    HelloServant::class => [
                        'endpoint' => 'tcp://localhost:7000'
                    ]
                ]
            ]
        ]
    ],
];
```

Let's modify `src/application/controller/IndexController.php` to join the process of calling the service:

```php
<?php

declare(strict_types=1);

namespace app2\application\controller;

use kuiper\di\attribute\Controller;
use kuiper\web\AbstractController;
use kuiper\web\annotation\GetMapping;
use app2\integration\app\HelloServant;

/**
 * @Controller
 */
class IndexController extends AbstractController
{
    /**
     * @Inject
     * @var HelloServant
     */
    private $helloServant;

n/**
     * @GetMapping("/")
     */
    public function index(): void
    {
        $this->getResponse()->getBody()->write($this->helloServant->hello("kuiper"));
    }
}
```

Start the service with `composer serve` and verify that the service call succeeds with `curl -v http://localhost:8000`.

## Service deployment

The process of building and creating applications for the TARS platform is not described in this document,
refer to the official documentation, and it is recommended to build through docker.

After the application development is complete, use the `composer pack` command to package the code
and upload the code to the tars platform to complete the service deployment.
It is recommended to use the `composer install --no-dev` command to reduce the code package size before packaging.
